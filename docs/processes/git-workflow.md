# Git Workflow

## Модель ветвления

Проект использует упрощенную модель Git Flow:

```
main (production)
  └── develop (staging/integration)
       ├── feature/* (новые функции)
       ├── fix/* (исправления багов)
       └── hotfix/* (критические исправления из main)
```

## Ветки

### `main`

- Production-ready код
- Защищена от прямых коммитов
- Сливается только через PR из `develop`
- После мерджа создается тег версии

### `develop`

- Интеграционная ветка для разработки
- Разрешены прямые коммиты и пуши (для быстрой разработки)
- Также может сливаться через PR из `feature/*` и `fix/*`
- Всегда должна быть в рабочем состоянии

### `feature/*`

- Ветки для новых функций
- Формат: `feature/краткое-описание` (например: `feature/add-budget-charts`)
- Отпочковывается от `develop`
- Сливается обратно в `develop` через PR
- Удаляется после мерджа

### `fix/*`

- Ветки для исправления багов
- Формат: `fix/краткое-описание` (например: `fix/transaction-sync-bug`)
- Отпочковывается от `develop`
- Сливается обратно в `develop` через PR

### `hotfix/*`

- Критические исправления в production
- Формат: `hotfix/краткое-описание`
- Отпочковывается от `main`
- Сливается в `main` и `develop` через PR

## Процесс работы

### Работа напрямую с develop

Для быстрой разработки можно коммитить и пушить напрямую в `develop`:

```bash
# Переключиться на develop и обновить
git checkout develop
git pull origin develop

# Внести изменения и закоммитить
git add .
git commit -m "fix: исправить баг"
git push origin develop
```

**Примечание**: Для больших изменений или когда нужен code review, рекомендуется использовать feature ветки и Pull Request.

### 1. Создание feature ветки

```bash
# Переключиться на develop и обновить
git checkout develop
git pull origin develop

# Создать новую feature ветку
git checkout -b feature/my-feature

# Запушить ветку в удаленный репозиторий
git push -u origin feature/my-feature
```

### 2. Разработка

- Делать коммиты по [Conventional Commits](COMMIT_CONVENTION.md)
- Pre-commit hooks автоматически проверят код перед коммитом
- Регулярно пушить изменения в удаленную ветку

```bash
# После изменений
git add .
git commit -m "feat: добавить новую функцию"
git push
```

### 3. Создание Pull Request

1. Перейти на GitHub и создать PR из `feature/*` в `develop`
2. Заполнить описание PR (что изменено, зачем)
3. Дождаться прохождения CI проверок
4. Дождаться code review (минимум 1 одобрение)
5. После одобрения и прохождения CI - смерджить PR

### 4. Релиз в production

1. Работа в `develop` с коммитами по [Conventional Commits](COMMIT_CONVENTION.md)
2. После пуша в `develop` автоматически запускается процесс релиза:
   - GitHub Actions workflow анализирует коммиты с последнего релиза
   - Определяет новую версию на основе типов коммитов
   - Обновляет `package.json` с новой версией
   - Генерирует `CHANGELOG.md` с описанием изменений
   - Создает Git тег (например, `v1.0.0`)
   - Создает GitHub Release с автоматически сгенерированными release notes
   - Коммитит изменения версии обратно в `develop`
3. Создать PR из `develop` в `main` с изменениями версии
4. После мерджа PR в `main` новая версия попадает в production

**Важно**: Используйте правильные типы коммитов для автоматического версионирования:

- `feat:` → minor версия (0.5.0 → 0.6.0)
- `fix:` → patch версия (0.5.0 → 0.5.1)
- `BREAKING CHANGE:` → major версия (0.5.0 → 1.0.0)

## Pre-commit Hooks

При каждом коммите автоматически запускаются:

- **ESLint**: проверка кода на ошибки
- **Prettier**: автоматическое форматирование кода

Если проверки не проходят, коммит будет заблокирован. Исправьте ошибки и попробуйте снова.

## CI/CD Pipeline

При создании PR автоматически запускаются проверки:

1. **Lint & Format Check**: проверка ESLint и Prettier
2. **Type Check**: проверка TypeScript типов
3. **Build**: сборка проекта

Все проверки должны пройти успешно перед мерджем.

## Автоматические релизы

Проект использует [semantic-release](https://github.com/semantic-release/semantic-release) для автоматизации процесса создания релизов.

### Как это работает

1. После пуша в `develop` запускается GitHub Actions workflow `release`
2. `semantic-release` анализирует все коммиты с последнего релиза
3. На основе типов коммитов (Conventional Commits) определяется новая версия:
   - `feat:` → **minor** версия (0.5.0 → 0.6.0)
   - `fix:` → **patch** версия (0.5.0 → 0.5.1)
   - `perf:` → **patch** версия (0.5.0 → 0.5.1)
   - `refactor:` → **patch** версия (0.5.0 → 0.5.1)
   - `BREAKING CHANGE:` → **major** версия (0.5.0 → 1.0.0)
4. Если есть изменения для релиза:
   - Автоматически обновляется `package.json` с новой версией
   - Генерируется `CHANGELOG.md` с описанием изменений
   - Создается Git тег (например, `v1.0.0`)
   - Создается GitHub Release с автоматически сгенерированными release notes
   - Изменения коммитятся обратно в `develop`
5. Когда готовы к релизу, создается PR из `develop` в `main` (включая изменения версии)
6. После мерджа PR в `main` новая версия попадает в production

**Преимущества этого подхода:**

- ✅ Соблюдает правила защиты ветки `main`
- ✅ Прозрачность: видно, что меняется в релизе через PR
- ✅ Возможность code review для изменений версии
- ✅ Не требует обхода правил защиты ветки

### Типы коммитов, которые не создают релиз

Следующие типы коммитов не влияют на версию:

- `build:` - изменения в системе сборки
- `chore:` - рутинные задачи
- `ci:` - изменения в CI/CD
- `style:` - форматирование кода
- `test:` - добавление или изменение тестов
- `docs:` - изменения в документации (кроме README)

### Просмотр релизов

- Все релизы доступны на странице [Releases](https://github.com/your-repo/releases) в GitHub
- История изменений доступна в файле `CHANGELOG.md` в корне проекта
- Версия проекта отображается в `package.json`

### Ручной запуск (для тестирования)

Для тестирования процесса релиза локально можно использовать:

```bash
# Dry-run (без создания релиза)
pnpm release:dry-run

# Полный запуск (только для тестирования, не использовать в production)
pnpm release
```

**Важно**: Ручной запуск `pnpm release` не должен использоваться в production, так как релизы создаются автоматически через GitHub Actions.

## Финальные проверки после имплементации

После завершения имплементации функциональности необходимо выполнить все проверки в правильном порядке:

### Порядок выполнения

1. **Форматирование (Prettier)** - автоисправление форматирования кода
2. **Линтинг (ESLint)** - проверка и автоисправление проблем кода
3. **Проверка типов (TypeScript)** - проверка типов без генерации файлов
4. **Сборка (Next.js)** - финальная проверка сборки проекта

### Команда для выполнения

Используйте скрипт `check:all` для последовательного выполнения всех проверок:

```bash
pnpm check:all
```

Или выполните команды вручную:

```bash
pnpm format && pnpm lint:fix && pnpm exec tsc --noEmit && pnpm build
```

### Отдельные команды

- `pnpm format` - форматирование всех файлов через Prettier
- `pnpm lint:fix` - проверка и автоисправление через ESLint
- `pnpm exec tsc --noEmit` - проверка типов TypeScript
- `pnpm build` - сборка проекта Next.js

**Важно**: Все команды выполняются последовательно, так как каждая последующая зависит от результатов предыдущей.

## Vercel Deploys

- **Preview Deploys**: автоматически создаются для всех PR
- **Staging Deploy**: автоматически создается при мердже в `develop` (если настроено)
- **Production Deploy**: автоматически создается при мердже в `main`

## FAQ

### Как обновить feature ветку с последними изменениями из develop?

```bash
git checkout feature/my-feature
git fetch origin
git merge origin/develop
# Или через rebase (если предпочитаете)
git rebase origin/develop
```

### Что делать если есть конфликты при мердже?

1. Обновить feature ветку с последними изменениями из develop
2. Разрешить конфликты локально
3. Запушить изменения
4. PR обновится автоматически

### Можно ли коммитить напрямую в develop или main?

- **develop**: Да, прямые коммиты и пуши разрешены для быстрой разработки
- **main**: Нет. Все изменения в main должны проходить через Pull Request из develop для обеспечения code review и проверок CI

### Как отменить изменения в feature ветке?

```bash
# Отменить последний коммит (сохранив изменения)
git reset --soft HEAD~1

# Отменить последний коммит (удалив изменения)
git reset --hard HEAD~1

# Отменить все локальные изменения
git checkout .
```

### Как удалить локальную ветку после мерджа?

```bash
# Удалить локальную ветку
git branch -d feature/my-feature

# Удалить удаленную ветку (обычно делается автоматически при мердже PR)
git push origin --delete feature/my-feature
```
